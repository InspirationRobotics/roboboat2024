#include <memory>

#include "rclcpp/rclcpp.hpp"
#include "dist_msg/msg/dist.hpp"
#include "vision_msgs/msg/detection2_d_array.hpp"
#include "message_filters/synchronizer.h"
#include "message_filters/subscriber.h"

using std::placeholders::_1;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAP_WIDTH 120
#define MAP_HEIGHT 120

/* datastructure stuff ------------------------- */

typedef struct pose {
	double x;
	double y;
	double z;
} pose;

/* standalone object with pose */
typedef struct obj {
	char *mission;
	char *id;
	char *type;
	pose p;

	int times_seen;
} obj;

// typedef struct obj_lst {
// 	int index;
// 	struct obj_lst *next;

// 	obj o;
// } obj_lst;

// typedef struct cell {
// 	int times_seen;
// 	obj_lst *list;
// } cell;

// typedef struct map {
// 	int width;
// 	int height;
// 	cell ***grid;
// } map;

// obj make_obj(char *mission, char *id, char *type, int times_seen)
// {
// 	obj o;
// 	o.mission = mission;
// 	o.id = id;
// 	o.type = type;
// 	o.times_seen = times_seen;

// 	return o;
// }

// obj_lst *make_obj_lst(obj o)
// {
// 	obj_lst *lst = (obj_lst *) calloc(1, sizeof(obj_lst));
// 	lst->o = o;

// 	return lst;
// }

// cell *make_cell()
// {
// 	cell *c = calloc(1, sizeof(cell));
// 	c->list = make_obj_lst(make_obj("nil", "nil", "nil", 0));
// 	c->times_seen = 0;

// 	return c;
// }

// map make_map(int width, int height)
// {
// 	map m;
// 	m.width = width;
// 	m.height = height;
	
// 	cell ***grid = calloc(height, sizeof(cell **));
// 	for (int i = 0; i < height; i++) {
// 	        grid[i] = calloc(width, sizeof(cell *));
// 		for (int j = 0; j < width; j++)
// 			grid[i][j] = make_cell();
// 	}

// 	m.grid = grid;

// 	return m;
// }

// void append_to_cell(cell *c, obj o)
// {
// 	obj_lst *l = c->list;

// 	if (l->next)
// 		l = l->next;

// 	l->next = make_obj_lst(o);	
// }

// void free_obj_lst(obj_lst *l)
// {
// 	if (l->next) {
// 		free_obj_lst(l->next);
// 	} else {
// 		free(l);
// 	}	
// }

// void free_cell(cell *c) {
// 	free_obj_lst(c->list);
// 	free(c);
// }

// void free_map(map m) {
//         for (int i = 0; i < m.height; i++) {
// 		for (int j = 0; j < m.width; j++) {
// 			free_cell(m.grid[i][j]);
// 		}
// 		free(m.grid[i]);
// 	}
// 	free(m.grid);
// }

// cell *get_cell(map m, int i, int j)
// {
// 	return m.grid[i][j];
// }

void print_obj(obj o)
{
	printf("mission: %s\n", o.mission);
	printf("id: %s\n", o.id);
	printf("type: %s\n", o.type);
	printf("times seen: %d\n", o.times_seen);
	printf("--\n");
}

// void print_cell(cell *c)
// {
// 	printf("times seen (cell): %d\n", c->times_seen); 
// 	obj_lst *l = c->list;

// 	while (l)
// 	{
// 		print_obj(l->o);
// 		l = l->next;
// 	}
// }

// /* map stuff ------------------------- */

// pose map_position;
// double heading = 0;
// double map_heading = 0.785398163;

// double normalize_angle(double angle)
// {
// 	double PI = 3.14159;
// 	if (angle > 2 * PI)
// 		angle = fmod(angle, (2 * PI));
// 	if (angle < 0)
// 	{
// 		if (angle < -2 * PI)
// 			angle = fmod(angle, (-2 * PI));
// 		angle += 2 * PI;
// 	}
// 	return angle; 
// }

// double angle_between_points(pose p, pose q)
// {
// 	double PI = 3.141592;
	
// 	double angle = atan(fabs(q.y - p.y) / fabs(q.x - p.x));
// 	if (p.x > p.y)
// 		angle = PI - angle;
// 	if (p.y > q.y)
// 		angle = 2 * PI - angle;
	
// 	return angle;
// }

// pose rotate(pose p, double degrees)
// {
// 	pose origin;
// 	origin.x = 0;
// 	origin.y = 0;
	
// 	double magnitude = sqrt((p.x * p.x) + (p.y * p.y));
// 	double angle = angle_between_points(origin, p);
// 	p.x = cos(angle + degrees) * magnitude;
// 	p.y = sin(angle + degrees) * magnitude;

// 	return p;
// }
 
// pose ll_to_map_coord(pose origin, pose ll)
// {
// 	int meters_per_gps_deg = 111139;
// 	pose meters;
// 	int magnitude;
	
// 	meters.x = (ll.x - origin.x) * meters_per_gps_deg;
// 	meters.y = (ll.y - origin.x) * meters_per_gps_deg;

// 	pose map_coords = rotate(meters, map_heading);

// 	map_coords.x += 59;
// 	map_coords.y += 59;
	
// 	return map_coords;
// }

// void add_sighting_to_cell(cell *c, obj o)
// {
// 	obj_lst *l = c->list;

// 	while (l)
// 	{
// 		if (strcmp(l->o.type, o.type) == 0)
// 		{
// 			(l->o.times_seen)++;
// 			return;
// 		}
// 		l = l->next;
// 	}
	
// 	append_to_cell(c, make_obj("nil", "nil", o.type, 1));
// }

// void place_rel_obj(map m, obj o)
// {
// 	map_position.x = 59; // middle of map
// 	map_position.y = 59;
// 	o.p = rotate(o.p, heading);
// 	int i = (int) (map_position.x + o.p.x);
// 	int j = (int) (map_position.y + o.p.y);
// 	add_sighting_to_cell(get_cell(m, i, j), o);

// 	printf("%d %d\n", i, j);
// }

/* id determination ------------------------- */

/* void categorize_buoys_by_id_gate(map m) */
/* { */
/* 	int gbuoy_one; */
/* 	int gbuoy_two;  */
/* 	for (int i = 0; i < m.width; i++) */
/* 	{ */
/* 		for (int j = 0; i < m.height; j++) */
/* 		{ */
/* 			count_type() */
/* 		} */
/* 	} */
/* } */

obj *objs_in_frame;
/* subscribers and publishers -------------------------------- */

class Mapper : public rclcpp::Node
{
public:
	Mapper()
		: Node("mapper")
		{
			message_filters::Subscriber<dist_msg::msg::Dist> dist_sub_;
			message_filters::Subscriber<vision_msgs::msg::Detection2DArray> bbox_sub_;
			dist_sub_.subscribe(this, "/distances");
			bbox_sub_.subscribe(this, "/right_set/bbox");

			typedef message_filters::sync_policies::ApproximateTime<vision_msgs::msg::Detection2DArray, dist_msg::msg::Dist> approximate_policy;
			message_filters::Synchronizer<approximate_policy>syncApproximate(approximate_policy(10), bbox_sub_, dist_sub_);
			syncApproximate.setMaxIntervalDuration(rclcpp::Duration(3,0));
			syncApproximate.registerCallback(&Mapper::perception_callback, this);
		}

private:
	void perception_callback(const vision_msgs::msg::Detection2DArray::SharedPtr bb,
			   const dist_msg::msg::Dist::SharedPtr d) const
		{
			free(objs_in_frame);
			int size = d->count;
			objs_in_frame = calloc(size, sizeof(obj)); 
			
			free(distances);
			int count = msg->count; 
			distances = calloc(count, sizeof(double));

			obj o;
			for (int i = 0; i < size; i++)
			{
				o.type = dist->obj_classes[i];
			// 	o.p.x = dist->distances[i] * cos((3.14159 / 2.0) - ((bb->detections[i].bbox.center - 540) / 540) * 60);
			// 	o.p.y = dist->distances[i] * sin((3.14159 / 2.0) - ((bb->detections[i].bbox.center - 540) / 540) * 60);

			// 	objs_in_frame[i] = o;
			// }

			// for (int i = 0; i < size; i++)
			// {
			// 	print_obj(objs_in_frame[i]);
			// }
			// printf("__________________________ \n");
			}
		}

};

int main(int argc, char * argv[])
{
	rclcpp::init(argc, argv);
	rclcpp::spin(std::make_shared<Mapper>());
	rclcpp::shutdown();
        
	return 0;
}

